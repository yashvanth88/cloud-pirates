name: CI/CD â€” Build & Deploy to Civo

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        id: build-image
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/cloud-pirates:${{ github.sha }}
          file: ./backend/Dockerfile
          context: ./backend
          outputs: type=registry

  deploy-to-civo:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install civo CLI
        run: |
          set -euo pipefail
          echo "Looking up latest civo CLI release asset via GitHub API"
          ASSET_URL=$(curl -s "https://api.github.com/repos/civo/cli/releases/latest" \
            | grep "browser_download_url" \
            | grep -i "linux" \
            | grep -i "amd64" \
            | head -n1 \
            | cut -d '"' -f4)
          if [ -z "$ASSET_URL" ]; then
            echo "Could not find linux/amd64 asset URL for civo CLI" >&2
            exit 1
          fi
          echo "Found asset: $ASSET_URL"
          OUT="/tmp/civo.tar.gz"
          curl -L --retry 3 --fail -o "$OUT" "$ASSET_URL"
          echo "Downloaded file info:"; file "$OUT" || true
          tar -xzf "$OUT" -C /tmp
          sudo mv /tmp/civo /usr/local/bin/civo
          sudo chmod +x /usr/local/bin/civo

      - name: Authenticate Civo
        env:
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
        run: |
          civo apikey save cicd $CIVO_API_KEY || true

      - name: Ensure Kubernetes cluster
        env:
          CLUSTER_NAME: cloud-pirates-cluster
        run: |
          if ! civo kubernetes show $CLUSTER_NAME >/dev/null 2>&1; then
            civo kubernetes create $CLUSTER_NAME --wait --nodes 2 --size g4s.kube.small
          fi
          # Save kubeconfig for the cluster. Different civo CLI versions
          # may either write a file named kubeconfig-<name>.yaml or print
          # to stdout; try the save command then move the file if present.
          # Try saving kubeconfig to a temp file (some civo CLI versions
          # print to stdout), then fall back to moving a named file if present.
          civo kubernetes kubeconfig save $CLUSTER_NAME > /tmp/kubeconfig 2>/dev/null || true
          if [ -s "/tmp/kubeconfig" ]; then
            mkdir -p $HOME/.kube
            mv /tmp/kubeconfig $HOME/.kube/config
          fi
          if [ -f "kubeconfig-$CLUSTER_NAME.yaml" ]; then
            mkdir -p $HOME/.kube
            mv "kubeconfig-$CLUSTER_NAME.yaml" $HOME/.kube/config
          fi
          export KUBECONFIG=$HOME/.kube/config

      - name: Configure kubectl
        run: kubectl version --client

      - name: Create Kubernetes secret
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SPACES_ENDPOINT: ${{ secrets.SPACES_ENDPOINT }}
          SPACES_KEY: ${{ secrets.SPACES_KEY }}
          SPACES_SECRET: ${{ secrets.SPACES_SECRET }}
          SPACES_BUCKET: ${{ secrets.SPACES_BUCKET }}
          INFERENCE_URL: ${{ secrets.INFERENCE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
        run: |
          KUBECONFIG_PATH="$HOME/.kube/config"
          if [ ! -s "$KUBECONFIG_PATH" ]; then
            echo "ERROR: kubeconfig not found at $KUBECONFIG_PATH. Cannot create secrets or deploy." >&2
            echo "Dumping /home/runner/.kube listing for debugging:" || true
            ls -la "$HOME/.kube" || true
            exit 1
          fi

          kubectl --kubeconfig="$KUBECONFIG_PATH" create secret generic cloud-pirates-secrets \
            --from-literal=DATABASE_URL="$DATABASE_URL" \
            --from-literal=SPACES_ENDPOINT="$SPACES_ENDPOINT" \
            --from-literal=SPACES_KEY="$SPACES_KEY" \
            --from-literal=SPACES_SECRET="$SPACES_SECRET" \
            --from-literal=SPACES_BUCKET="$SPACES_BUCKET" \
            --from-literal=INFERENCE_URL="$INFERENCE_URL" \
            --from-literal=REDIS_URL="$REDIS_URL" --dry-run=client -o yaml | kubectl --kubeconfig="$KUBECONFIG_PATH" apply -f -

      - name: Deploy to cluster
        env:
          IMAGE: ghcr.io/${{ github.repository_owner }}/cloud-pirates:${{ github.sha }}
        run: |
          # Apply manifests and set the container image for deployments
          kubectl apply -f k8s/deployment.yaml
          kubectl set image deployment/cloud-pirates-web web=$IMAGE || true
          kubectl set image deployment/cloud-pirates-worker worker=$IMAGE || true
          kubectl apply -f k8s/migrate-job.yaml

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/cloud-pirates-web --timeout=120s || true
          kubectl rollout status deployment/cloud-pirates-worker --timeout=120s || true
