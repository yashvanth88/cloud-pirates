name: CI/CD â€” Build & Deploy to Civo

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        id: build-image
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/cloud-pirates:${{ github.sha }}
          file: ./backend/Dockerfile
          context: ./backend
          outputs: type=registry

  deploy-to-civo:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install civo CLI
        run: |
          set -euo pipefail
          echo "Looking up latest civo CLI release asset via GitHub API"
          ASSET_URL=$(curl -s "https://api.github.com/repos/civo/cli/releases/latest" \
            | grep "browser_download_url" \
            | grep -i "linux" \
            | grep -i "amd64" \
            | head -n1 \
            | cut -d '"' -f4)
          if [ -z "$ASSET_URL" ]; then
            echo "Could not find linux/amd64 asset URL for civo CLI" >&2
            exit 1
          fi
          echo "Found asset: $ASSET_URL"
          OUT="/tmp/civo.tar.gz"
          curl -L --retry 3 --fail -o "$OUT" "$ASSET_URL"
          echo "Downloaded file info:"; file "$OUT" || true
          tar -xzf "$OUT" -C /tmp
          sudo mv /tmp/civo /usr/local/bin/civo
          sudo chmod +x /usr/local/bin/civo

      - name: Authenticate Civo
        env:
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
        run: |
          civo apikey save cicd $CIVO_API_KEY || true

      - name: Ensure Kubernetes cluster
        env:
          CLUSTER_NAME: cloud-pirates-cluster
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
        run: |
          set -euo pipefail
          if ! civo kubernetes show $CLUSTER_NAME >/dev/null 2>&1; then
            civo kubernetes create $CLUSTER_NAME --wait --nodes 2 --size g4s.kube.small
          fi
          
          # Fetch kubeconfig directly via Civo API
          echo "Fetching cluster list from Civo API"
          curl -s -H "Authorization: Bearer $CIVO_API_KEY" "https://api.civo.com/v2/kubernetes" -o /tmp/civo-clusters.json
          
          # Extract cluster ID using Python
          cat > /tmp/extract_cluster_id.py <<'PYEOF'
          import json
          import sys
          try:
              with open('/tmp/civo-clusters.json') as f:
                  data = json.load(f)
          except Exception as e:
              print(f"Error loading JSON: {e}", file=sys.stderr)
              sys.exit(1)
          
          arr = data.get('items') or data.get('kubernetes_clusters') or []
          if isinstance(data, list):
              arr = data
          
          cluster_name = sys.argv[1] if len(sys.argv) > 1 else ''
          for c in arr:
              if c.get('name') == cluster_name:
                  print(c.get('id') or c.get('cluster_id') or '')
                  sys.exit(0)
          sys.exit(1)
          PYEOF
          
          CLUSTER_ID=$(python3 /tmp/extract_cluster_id.py "$CLUSTER_NAME")
          
          if [ -z "$CLUSTER_ID" ]; then
            echo "ERROR: Could not find cluster ID for $CLUSTER_NAME" >&2
            exit 1
          fi
          
          echo "Found cluster ID: $CLUSTER_ID"
          echo "Fetching kubeconfig from Civo API"
          curl -s -H "Authorization: Bearer $CIVO_API_KEY" "https://api.civo.com/v2/kubernetes/$CLUSTER_ID/kubeconfig" -o /tmp/kubeconfig-api
          
          if [ ! -s /tmp/kubeconfig-api ]; then
            echo "ERROR: Civo API did not return kubeconfig" >&2
            exit 1
          fi
          
          mkdir -p $HOME/.kube
          mv /tmp/kubeconfig-api $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "Successfully saved kubeconfig to $HOME/.kube/config"
          export KUBECONFIG=$HOME/.kube/config

      - name: Configure kubectl
        run: kubectl version --client

      - name: Fetch kubeconfig via Civo API (fallback)
        if: always()
        env:
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
          CLUSTER_NAME: cloud-pirates-cluster
        run: |
          set -euo pipefail
          KUBE_PATH="$HOME/.kube/config"
          if [ -s "$KUBE_PATH" ]; then
            echo "kubeconfig already present; skipping API fetch"
            exit 0
          fi
          echo "Attempting to fetch kubeconfig via Civo API"
          curl -s -H "Authorization: Bearer $CIVO_API_KEY" "https://api.civo.com/v2/kubernetes" -o /tmp/civo-clusters.json || true
          
          # Extract cluster ID using Python (fallback)
          cat > /tmp/extract_cluster_id_fallback.py <<'PYEOF'
          import json
          import sys
          try:
              with open('/tmp/civo-clusters.json') as f:
                  data = json.load(f)
          except Exception:
              sys.exit(0)
          
          arr = None
          if isinstance(data, list):
              arr = data
          elif isinstance(data, dict):
              for k in ('kubernetes_clusters', 'items', 'clusters'):
                  if k in data and isinstance(data[k], list):
                      arr = data[k]
                      break
              if arr is None:
                  for v in data.values():
                      if isinstance(v, list):
                          arr = v
                          break
          
          if not arr:
              sys.exit(0)
          
          cluster_name = sys.argv[1] if len(sys.argv) > 1 else ''
          for c in arr:
              if c.get('name') == cluster_name or c.get('cluster_name') == cluster_name:
                  print(c.get('id') or c.get('uuid') or c.get('cluster_id') or '')
                  sys.exit(0)
          sys.exit(0)
          PYEOF
          
          CLUSTER_ID=$(python3 /tmp/extract_cluster_id_fallback.py "$CLUSTER_NAME")
          
          if [ -z "$CLUSTER_ID" ]; then
            echo "Cluster ID not found; aborting API fetch" >&2
            exit 0
          fi
          echo "Found cluster ID: $CLUSTER_ID"
          curl -s -H "Authorization: Bearer $CIVO_API_KEY" "https://api.civo.com/v2/kubernetes/$CLUSTER_ID/kubeconfig" -o /tmp/kubeconfig-api || true
          if [ -s /tmp/kubeconfig-api ]; then
            mkdir -p $HOME/.kube
            mv /tmp/kubeconfig-api $HOME/.kube/config
            chmod 600 $HOME/.kube/config || true
            echo "Wrote $HOME/.kube/config from Civo API"
          else
            echo "No kubeconfig returned from Civo API" >&2
          fi

      - name: Upload kubeconfig diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: civo-deploy-diagnostics-${{ github.run_id }}
          path: |
            /tmp/kubeconfig*
            /tmp/civo-clusters.json
            $HOME/.kube/config
        continue-on-error: true

      - name: Create Kubernetes secret
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SPACES_ENDPOINT: ${{ secrets.SPACES_ENDPOINT }}
          SPACES_KEY: ${{ secrets.SPACES_KEY }}
          SPACES_SECRET: ${{ secrets.SPACES_SECRET }}
          SPACES_BUCKET: ${{ secrets.SPACES_BUCKET }}
          INFERENCE_URL: ${{ secrets.INFERENCE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
        run: |
          set -euo pipefail
          KUBECONFIG_PATH="$HOME/.kube/config"
          if [ ! -s "$KUBECONFIG_PATH" ]; then
            echo "kubeconfig missing; attempting to fetch via Civo API"
            CLUSTER_NAME="cloud-pirates-cluster"
            curl -s -H "Authorization: Bearer $CIVO_API_KEY" "https://api.civo.com/v2/kubernetes" -o /tmp/civo-clusters.json || true
            
            # Extract cluster ID using Python (in secret creation step)
            cat > /tmp/extract_cluster_id_secret.py <<'PYEOF'
          import json
          import sys
          try:
              with open('/tmp/civo-clusters.json') as f:
                  data = json.load(f)
          except Exception:
              sys.exit(0)
          
          arr = None
          if isinstance(data, list):
              arr = data
          elif isinstance(data, dict):
              for k in ('kubernetes_clusters', 'items', 'clusters'):
                  if k in data and isinstance(data[k], list):
                      arr = data[k]
                      break
              if arr is None:
                  for v in data.values():
                      if isinstance(v, list):
                          arr = v
                          break
          
          if not arr:
              sys.exit(0)
          
          cluster_name = sys.argv[1] if len(sys.argv) > 1 else ''
          for c in arr:
              if c.get('name') == cluster_name or c.get('cluster_name') == cluster_name:
                  print(c.get('id') or c.get('uuid') or c.get('cluster_id') or '')
                  sys.exit(0)
          sys.exit(0)
          PYEOF
            
            CLUSTER_ID=$(python3 /tmp/extract_cluster_id_secret.py "$CLUSTER_NAME")
            
            if [ -n "$CLUSTER_ID" ]; then
              echo "Found cluster id: $CLUSTER_ID; fetching kubeconfig"
              curl -s -H "Authorization: Bearer $CIVO_API_KEY" "https://api.civo.com/v2/kubernetes/$CLUSTER_ID/kubeconfig" -o /tmp/kubeconfig-api || true
              if [ -s /tmp/kubeconfig-api ]; then
                mkdir -p $HOME/.kube
                mv /tmp/kubeconfig-api $KUBECONFIG_PATH
                chmod 600 $KUBECONFIG_PATH || true
                echo "Wrote kubeconfig to $KUBECONFIG_PATH"
              else
                echo "API did not return kubeconfig" >&2
              fi
            else
              echo "Could not find cluster id via API" >&2
            fi
          fi

          if [ ! -s "$KUBECONFIG_PATH" ]; then
            echo "ERROR: kubeconfig still missing at $KUBECONFIG_PATH; aborting secret creation" >&2
            ls -la "$HOME/.kube" || true
            exit 1
          fi

          kubectl --kubeconfig="$KUBECONFIG_PATH" create secret generic cloud-pirates-secrets \
            --from-literal=DATABASE_URL="$DATABASE_URL" \
            --from-literal=SPACES_ENDPOINT="$SPACES_ENDPOINT" \
            --from-literal=SPACES_KEY="$SPACES_KEY" \
            --from-literal=SPACES_SECRET="$SPACES_SECRET" \
            --from-literal=SPACES_BUCKET="$SPACES_BUCKET" \
            --from-literal=INFERENCE_URL="$INFERENCE_URL" \
            --from-literal=REDIS_URL="$REDIS_URL" --dry-run=client -o yaml | kubectl --kubeconfig="$KUBECONFIG_PATH" apply -f -

      - name: Deploy to cluster
        env:
          IMAGE: ghcr.io/${{ github.repository_owner }}/cloud-pirates:${{ github.sha }}
        run: |
          # Apply manifests and set the container image for deployments
          kubectl apply -f k8s/deployment.yaml
          kubectl set image deployment/cloud-pirates-web web=$IMAGE || true
          kubectl set image deployment/cloud-pirates-worker worker=$IMAGE || true
          kubectl apply -f k8s/migrate-job.yaml

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/cloud-pirates-web --timeout=120s || true
          kubectl rollout status deployment/cloud-pirates-worker --timeout=120s || true
