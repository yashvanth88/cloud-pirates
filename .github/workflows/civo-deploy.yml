name: CI/CD â€” Build & Deploy to Civo

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        id: build-image
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/cloud-pirates:${{ github.sha }}
          file: ./backend/Dockerfile
          context: ./backend
          outputs: type=registry

  deploy-to-civo:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install civo CLI
        run: |
          set -euo pipefail
          echo "Looking up latest civo CLI release asset via GitHub API"
          ASSET_URL=$(curl -s "https://api.github.com/repos/civo/cli/releases/latest" \
            | grep "browser_download_url" \
            | grep -i "linux" \
            | grep -i "amd64" \
            | head -n1 \
            | cut -d '"' -f4)
          if [ -z "$ASSET_URL" ]; then
            echo "Could not find linux/amd64 asset URL for civo CLI" >&2
            exit 1
          fi
          echo "Found asset: $ASSET_URL"
          OUT="/tmp/civo.tar.gz"
          curl -L --retry 3 --fail -o "$OUT" "$ASSET_URL"
          echo "Downloaded file info:"; file "$OUT" || true
          tar -xzf "$OUT" -C /tmp
          sudo mv /tmp/civo /usr/local/bin/civo
          sudo chmod +x /usr/local/bin/civo

      - name: Authenticate Civo
        env:
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
        run: |
          civo apikey save cicd $CIVO_API_KEY || true

      - name: Ensure Kubernetes cluster
        env:
          CLUSTER_NAME: cloud-pirates-cluster
          CIVO_API_KEY: ${{ secrets.CIVO_API_KEY }}
        run: |
          set -euo pipefail
          if ! civo kubernetes show $CLUSTER_NAME >/dev/null 2>&1; then
            civo kubernetes create $CLUSTER_NAME --wait --nodes 2 --size g4s.kube.small
          fi
          
          # Save kubeconfig using civo CLI - try multiple approaches
          echo "Saving kubeconfig using civo CLI"
          mkdir -p $HOME/.kube
          
          # Method 1: Output to stdout and redirect
          if civo kubernetes config $CLUSTER_NAME > $HOME/.kube/config 2>/dev/null; then
            echo "Method 1 succeeded: config to stdout"
          # Method 2: Use --save flag
          elif civo kubernetes config $CLUSTER_NAME --save 2>/dev/null; then
            echo "Method 2 succeeded: --save flag"
          # Method 3: Use --save --merge
          elif civo kubernetes config $CLUSTER_NAME --save --merge 2>/dev/null; then
            echo "Method 3 succeeded: --save --merge"
          else
            echo "ERROR: All kubeconfig methods failed" >&2
            echo "Trying to show cluster info for debugging:"
            civo kubernetes show $CLUSTER_NAME || true
            exit 1
          fi
          
          # Verify kubeconfig was created
          if [ ! -s "$HOME/.kube/config" ]; then
            echo "ERROR: kubeconfig not found or empty at $HOME/.kube/config" >&2
            ls -la $HOME/.kube/ || true
            exit 1
          fi
          
          chmod 600 $HOME/.kube/config
          echo "Successfully saved kubeconfig"

      - name: Configure kubectl
        run: |
          kubectl version --client
          kubectl cluster-info

      - name: Create Kubernetes secret
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SPACES_ENDPOINT: ${{ secrets.SPACES_ENDPOINT }}
          SPACES_KEY: ${{ secrets.SPACES_KEY }}
          SPACES_SECRET: ${{ secrets.SPACES_SECRET }}
          SPACES_BUCKET: ${{ secrets.SPACES_BUCKET }}
          INFERENCE_URL: ${{ secrets.INFERENCE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
        run: |
          kubectl create secret generic cloud-pirates-secrets \
            --from-literal=DATABASE_URL="$DATABASE_URL" \
            --from-literal=SPACES_ENDPOINT="$SPACES_ENDPOINT" \
            --from-literal=SPACES_KEY="$SPACES_KEY" \
            --from-literal=SPACES_SECRET="$SPACES_SECRET" \
            --from-literal=SPACES_BUCKET="$SPACES_BUCKET" \
            --from-literal=INFERENCE_URL="$INFERENCE_URL" \
            --from-literal=REDIS_URL="$REDIS_URL" --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to cluster
        env:
          IMAGE: ghcr.io/${{ github.repository_owner }}/cloud-pirates:${{ github.sha }}
        run: |
          # Apply manifests and set the container image for deployments
          kubectl apply -f k8s/deployment.yaml
          kubectl set image deployment/cloud-pirates-web web=$IMAGE || true
          kubectl set image deployment/cloud-pirates-worker worker=$IMAGE || true
          kubectl apply -f k8s/migrate-job.yaml

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/cloud-pirates-web --timeout=120s || true
          kubectl rollout status deployment/cloud-pirates-worker --timeout=120s || true
